// Generated by CoffeeScript 1.7.1
(function() {
  var Cluster, Decking, Docker, JSONStream, Logger, MultiplexStream, Parser, Runner, Table, async, child_process, docker, fs, host, isRunning, log, logStream, resolveContainers, validateContainerPresence, version;

  fs = require("fs");

  child_process = require("child_process");

  async = require("async");

  Docker = require("dockerode");

  JSONStream = require("JSONStream");

  Parser = require("./parser");

  Runner = require("./runner");

  Cluster = require("./cluster");

  Logger = require("./logger");

  Table = require("./table");

  MultiplexStream = require("./multiplex_stream");

  host = process.env.DOCKER_HOST || "/var/run/docker.sock";

  docker = new Docker({
    socketPath: host
  });

  log = Logger.log;

  logStream = function(name, data) {
    return log("" + (Table.padName(name, "(", ")")) + " " + data);
  };

  version = require("" + __dirname + "/../package.json").version;

  module.exports = Decking = (function() {
    function Decking(_arg) {
      var _ref;
      _ref = _arg != null ? _arg : {}, this.command = _ref.command, this.args = _ref.args;
      if (this.args == null) {
        this.args = [];
      }
      this.config = {};
    }

    Decking.prototype.parseConfig = function(data) {
      return JSON.parse(data);
    };

    Decking.prototype.loadConfig = function(file) {
      return Parser.load(this.parseConfig(fs.readFileSync(file)));
    };

    Decking.prototype.commands = {
      help: function(done) {
        var help;
        log("");
        help = "Usage: decking COMMAND [arg...]\n\nCommands:\n  build    build an image or pass 'all' to build all\n  create   create a cluster of containers\n  start    start a cluster\n  stop     stop a cluster\n  restart  restart a cluster\n  status   check the status of a cluster's containers\n  attach   attach to all running containers in a cluster\n\nVersion: " + version + "\n";
        log(help);
        return done(null);
      },
      build: function(done) {
        var image, images, key, val;
        image = this.args[0];
        if (image === "all") {
          images = (function() {
            var _ref, _results;
            _ref = this.config.images;
            _results = [];
            for (key in _ref) {
              val = _ref[key];
              _results.push(key);
            }
            return _results;
          }).call(this);
          return async.eachSeries(images, (function(_this) {
            return function(image, callback) {
              return _this.build(image, callback);
            };
          })(this), done);
        } else {
          return this.build(image, done);
        }
      },
      create: function(done) {
        return this._run("create", done);
      },
      start: function(done) {
        return this._run("start", done);
      },
      stop: function(done) {
        return this._run("stop", done);
      },
      restart: function(done) {
        return this._run("restart", done);
      },
      status: function(done) {
        return this._run("status", done);
      },
      attach: function(done) {
        return this._run("attach", done);
      }
    };

    Decking.prototype._run = function(cmd, done) {
      var cluster, key, target;
      cluster = this.args[0];
      if (!cluster) {
        if (Object.keys(this.config.clusters).length !== 1) {
          throw new Error("Please supply a cluster name");
        }
        for (key in this.config.clusters) {
          cluster = key;
        }
        log("Defaulting to cluster '" + cluster + "'");
      }
      target = this.config.clusters[cluster];
      if (!target) {
        throw new Error("Cluster " + cluster + " does not exist in decking.json");
      }
      if (target.group) {
        log("Using overrides from group '" + target.group + "'\n");
      }
      return this[cmd](target, done);
    };

    Decking.prototype.start = function(cluster, done) {
      var iterator;
      iterator = function(details, callback) {
        var container, name;
        name = details.name;
        container = docker.getContainer(name);
        return isRunning(container, function(err, running) {
          if (!running) {
            Table.render(name, "starting...");
            return container.start(function(err) {
              if (err) {
                return callback(err);
              }
              Table.renderOk(name);
              return callback(null);
            });
          } else {
            Table.render(name, "already running");
            return callback(null);
          }
        });
      };
      return resolveContainers(this.config, cluster, function(list) {
        return validateContainerPresence(list, function(err) {
          if (err) {
            return done(err);
          }
          return async.eachSeries(list, iterator, done);
        });
      });
    };

    Decking.prototype.stop = function(cluster, done) {
      var iterator;
      iterator = function(details, callback) {
        var container, name;
        name = details.name;
        container = docker.getContainer(name);
        return isRunning(container, function(err, running) {
          if (running) {
            Table.render(name, "stopping...");
            return container.stop({
              t: 5
            }, function(err) {
              if (err) {
                return callback(err);
              }
              Table.renderOk(name);
              return callback(null);
            });
          } else {
            Table.render(name, "already stopped");
            return callback(null);
          }
        });
      };
      return resolveContainers(this.config, cluster, function(list) {
        return validateContainerPresence(list, function(err) {
          if (err) {
            return done(err);
          }
          return async.eachSeries(list, iterator, done);
        });
      });
    };

    Decking.prototype.restart = function(cluster, done) {
      var iterator;
      iterator = function(details, callback) {
        var container, name;
        name = details.name;
        container = docker.getContainer(name);
        return isRunning(container, function(err, running) {
          if (running) {
            Table.render(name, "restarting...");
            return container.stop({
              t: 5
            }, function(err) {
              if (err) {
                return callback(err);
              }
              return container.start(function(err) {
                if (err) {
                  return callback(err);
                }
                Table.renderOk(name);
                return callback(null);
              });
            });
          } else {
            Table.render(name, "starting...");
            return container.start(function(err) {
              if (err) {
                return callback(err);
              }
              Table.renderOk(name);
              return callback(null);
            });
          }
        });
      };
      return resolveContainers(this.config, cluster, function(list) {
        return validateContainerPresence(list, function(err) {
          if (err) {
            return done(err);
          }
          return async.eachSeries(list, iterator, done);
        });
      });
    };

    Decking.prototype.attach = function(cluster, done) {
      var attach, iterator, reAttach, timeout;
      timeout = 600;
      reAttach = function(name, container, attempts) {
        if (attempts == null) {
          attempts = 0;
        }
        return setTimeout(function() {
          return isRunning(container, function(err, running) {
            if (running) {
              return attach(name, container, false, function() {
                return logStream(name, "re-attached");
              });
            } else {
              if (attempts < 200) {
                return reAttach(name, container, attempts + 1);
              } else {
                return logStream(name, "max re-attach attempts reached, bailing...");
              }
            }
          });
        }, timeout);
      };
      attach = function(name, container, fetchLogs, callback) {
        var options;
        options = {
          stream: true,
          stdout: true,
          stderr: true,
          tty: false,
          logs: fetchLogs
        };
        return container.attach(options, function(err, stream) {
          new MultiplexStream(container, stream, Table.padName(name, "(", ")"));
          stream.on("end", function() {
            logStream(name, "gone away, will try to re-attach for two minutes...");
            return reAttach(name, container);
          });
          return typeof callback === "function" ? callback(err) : void 0;
        });
      };
      iterator = function(details, callback) {
        var container;
        container = docker.getContainer(details.name);
        return attach(details.name, container, true, callback);
      };
      return resolveContainers(this.config, cluster, function(list) {
        return validateContainerPresence(list, function(err) {
          if (err) {
            return done(err);
          }
          return async.eachSeries(list, iterator, done);
        });
      });
    };

    Decking.prototype.status = function(cluster, done) {
      var iterator;
      iterator = function(details, callback) {
        var container, name;
        name = details.name;
        container = docker.getContainer(name);
        return container.inspect(function(err, data) {
          var ip, local, str, _ref;
          if (err) {
            Table.render(name, "does not exist");
          } else if (data.State.Running) {
            str = "running  ";
            ip = data.NetworkSettings.IPAddress;
            str += ip;
            _ref = data.NetworkSettings.Ports;
            for (local in _ref) {
              host = _ref[local];
              host = host != null ? host[0] : void 0;
              str += "  ";
              if (host) {
                str += "" + host.HostIp + ":" + host.HostPort + "->";
              }
              str += local;
            }
            Table.render(name, str);
          } else {
            Table.render(name, "stopped");
          }
          return callback(null);
        });
      };
      return resolveContainers(this.config, cluster, function(list) {
        return async.eachLimit(list, 3, iterator, done);
      });
    };

    Decking.prototype.create = function(cluster, done) {
      var commands, createIterator, fetchIterator, stopIterator;
      commands = [];
      fetchIterator = function(details, callback) {
        var command, container, name;
        name = details.name;
        container = docker.getContainer(name);
        command = {
          name: name,
          container: container
        };
        return container.inspect(function(err, data) {
          var key, run, sortedArgs, val, _fn;
          if (!err) {
            command.exists = true;
            commands.push(command);
            return callback(null);
          }
          run = [];
          sortedArgs = Runner.sortArgs(details.object);
          _fn = function(key, val) {
            return run.push(function(done) {
              return Runner.getArg(key, val, details, done);
            });
          };
          for (key in sortedArgs) {
            val = sortedArgs[key];
            _fn(key, val);
          }
          return async.series(run, function(err, results) {
            if (err) {
              throw err;
            }
            command.exec = Runner.formatArgs(name, results);
            commands.push(command);
            return callback(null);
          });
        });
      };
      createIterator = function(command, callback) {
        var name;
        name = command.name;
        if (command.exists) {
          Table.render(name, "already exists - running in case of dependents");
          return isRunning(command.container, function(err, running) {
            if (!running) {
              return command.container.start(callback);
            }
            return command.container.stop({
              t: 5
            }, function(err) {
              return command.container.start(callback);
            });
          });
        }
        Table.render(name, "creating...");
        return child_process.exec(command.exec, function(err) {
          if (err) {
            return callback(err);
          }
          Table.renderOk(name);
          return callback(null);
        });
      };
      stopIterator = function(details, callback) {
        var container;
        container = docker.getContainer(details.name);
        return container.stop({
          t: 5
        }, callback);
      };
      return Cluster.resolveContainers(this.config, cluster, function(list) {
        return async.eachSeries(list, fetchIterator, function(err) {
          if (err) {
            throw err;
          }
          Table.setContainers(list);
          return async.eachSeries(commands, createIterator, function(err) {
            if (err) {
              throw err;
            }
            return setTimeout(function() {
              return async.eachLimit(list, 5, stopIterator, done);
            }, 1000);
          });
        });
      });
    };

    Decking.prototype.build = function(image, done) {
      var options, tar, target, targetPath;
      if (!image) {
        throw new Error("Please supply an image name to build");
      }
      log("Looking up build data for " + image);
      target = this.config.images[image];
      if (!target) {
        throw new Error("Image " + image + " does not exist in decking.json");
      }
      targetPath = "" + target + "/Dockerfile";
      log("Building image " + image + " from " + targetPath);
      fs.createReadStream(targetPath).pipe(fs.createWriteStream("./Dockerfile"));
      options = {
        t: image
      };
      if (this.hasArg("--no-cache")) {
        log("Not using image cache");
        options.nocache = true;
      }
      log("Uploading compressed context...");
      tar = child_process.spawn("tar", ["-c", "-", "./"]);
      return docker.buildImage(tar.stdout, options, function(err, res) {
        fs.unlink("./Dockerfile", function(err) {
          if (err) {
            return log("[WARN] Could not remove Dockerfile");
          }
        });
        if (err) {
          return done(err);
        }
        if (res.headers["content-type"] === "application/json") {
          res.pipe(JSONStream.parse("stream")).pipe(process.stdout);
        } else {
          res.pipe(process.stdout);
        }
        return res.on("end", done);
      });
    };

    Decking.prototype.execute = function(done) {
      var fn;
      if (!this.command || this.command === "-h" || this.command === "--help") {
        this.command = "help";
      }
      fn = this.commands[this.command];
      if (typeof fn !== "function") {
        throw new Error("Unknown method " + this.command);
      }
      if (this.command !== "help") {
        this.config = this.loadConfig("./decking.json");
      }
      return fn.call(this, function(err) {
        if (err) {
          throw err;
        }
      });
    };

    Decking.prototype.hasArg = function(arg) {
      return this.args.indexOf(arg) !== -1;
    };

    return Decking;

  })();

  resolveContainers = function(config, cluster, callback) {
    return Cluster.resolveContainers(config, cluster, function(list) {
      Table.setContainers(list);
      return callback(list);
    });
  };

  validateContainerPresence = function(list, done) {
    var iterator;
    iterator = function(details, callback) {
      var container, name;
      name = details.name;
      container = docker.getContainer(name);
      return container.inspect(callback);
    };
    return async.eachSeries(list, iterator, done);
  };

  isRunning = function(container, callback) {
    return container.inspect(function(err, data) {
      if (err) {
        return callback(err);
      }
      return callback(null, data.State.Running);
    });
  };

}).call(this);
