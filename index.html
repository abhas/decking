<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Create, manage and run clusters of Docker containers using Node.js | decking.io</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>decking</h1>
        <h2>Create, manage and run clusters of Docker containers</h2>
        <a href="https://github.com/makeusabrew/decking" class="button"><small>View project on </small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <!--<h1> <span class="octicon octicon-link"></span>Simplified management for clusters of Docker containers</h1>-->

<p>Decking aims to simplify the creation, organsation and running of clusters
of Docker containers in a way which is familiar to developers;
by reading information from a <code>decking.json</code> package file
on a project by project basis. You can view a
<a href="http://showterm.io/3b45095fa0917c4e6c1b7">showterm recording</a>
of decking in action or check out a simple
<a href="https://github.com/makeusabrew/decking-example">example project</a>.</p>

<h2>
<a name="installation" class="anchor"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Decking is written in <a href="http://nodejs.org">Node.js</a>. Although under heavy development, the more recent releases on npm are stable:</p>

<pre class="reduced">$ [sudo] <b>npm install -g decking</b></pre>

<p>Alternatively, just clone the repo and run <code>./bin/decking</code>.</p>

<p>Once installed decking can be run (without arguments) from anywhere:</p>
<pre class="reduced reduced--alot">$ <b>decking</b>

Usage: decking COMMAND [arg...]

Commands:
  build    build an image or pass 'all' to build all
  create   create a cluster of containers
  start    start a cluster
  stop     stop a cluster
  restart  restart a cluster
  status   check the status of a cluster's containers
  attach   attach to all running containers in a cluster
</pre>

<p>These commands only make sense with some context&mdash;provided
by a local <b>decking.json</b> file.</p>

<h2>
<a name="about" class="anchor"><span class="octicon octicon-link"></span></a>Why decking?</h2>

<!--<p>Possible note here about lack of metadata storage with Docker</p>-->
<p>While <a href="http://www.docker.io/">Docker</a> is fantastic, it lacks
any way of associating valuable metadata with images or containers. A Dockerfile
can&rsquo;t enforce that it be built as a certain image name. More importantly, an
image can&rsquo;t enforce that it be invoked with certain runtime values when
it is used to create a container. Docker provides flexible, abstract
building blocks. Decking transforms these building blocks into
concrete implementations of services&mdash;and clusters of services&mdash;in a
robust, repeatable, configuration-driven manner. It allows simple but powerful
dependency modelling and takes all the hassle (and error) out of starting
clusters of containers in the correct dependency order. It allows optional
overrides to fine-tune cluster configuration on a per-environment basis.

<p>It simplifies the <b>building of images</b> based on local Dockerfiles which
can ordinarily be a time-consuming and error prone process (building the wrong
Dockerfile as the wrong image, and having to move the Dockerfile to the root of
a project in order to make the <code>ADD</code> directive work smoothly).</p>

<p>It simplifies the <b>creation of containers</b> by considering
<code>docker run</code> parameters to be part of the definition of each
container, meaning less room for error as each developer doesn&rsquo;t have
to remember the correct runtime parameters to use when creating each
container.</p>

<p>It simplifies the <b>orchestration of containers</b> by allowing dependencies
to be specified, ensuring that all containers forming part of a cluster are
started in the correct order such that <code>-link</code> parameters work as
expected. Entire clusters of containers can be started, stopped or attached to
with a single command, without having to worry about (re)starting them in
dependency order.</p>

<h2>
<a name="format" class="anchor"><span class="octicon octicon-link"></span></a>The decking.json file format</h2>

<p>The decking.json format aims to be clear, concise and simple. Note that the file
must be present in the current working directory; decking will not recurse up parent
directories looking for a valid definition file. The top-level keys are:</p>

<pre><code>"images":     { /* the images which power your containers */ },
"containers": { /* the container templates which make up your clusters */ },
"clusters":   { /* lists of containers which combine to form a cluster */ },
"groups":     { /* optional overrides for different environments */ }
</code></pre>

<h3>
<a name="format-images" class="anchor"><span class="octicon octicon-link"></span></a>images</h3>

<ul class="requirements">
  <li>required: <b>no</b></li>
</ul>

<p>Images define the templates from which containers are built; decking gives them
a boost by being able to build them in batches and resolving commonly experienced issues with
Docker&rsquo;s &lsquo;context&rsquo; restrictions.</p>

<p>Each key is the name of the image you want to build. Each value is the location of
the <em>local</em> Dockerfile relative to the project root. Only local images
can be built at the moment, although eventually you&rsquo;ll be able to specify tag names
as values in to build an image from the Docker Index instead.</p>

<pre><code>"images": {
  "makeusabrew/nodeflakes": "./docker/base",
  "makeusabrew/nodeflakes-server": "./docker/server",
  "makeusabrew/nodeflakes-consumer": "./docker/consumer",
  "makeusabrew/nodeflakes-processor": "./docker/processor"
}
</code></pre>

<p>When building an image the relevant Dockerfile will be copied to the root
of your project (i.e. to the same directory as your decking.json file) such
that any <code>ADD</code> directives will be relative to your project root.</p>

<h3>
<a name="format-containers" class="anchor"><span class="octicon octicon-link"></span></a>containers</h3>

<ul class="requirements">
  <li>required: <b>yes</b></li>
</ul>

<p>Containers define the runtime configuration for a given image. They let you
model services&mdash;and crucially, their dependencies&mdash;in a clear, clean
and repeatable manner, meaning you don&rsquo;t have to remember all those arguments
when creating a new container.</p>

<p>Each key is the name you want to assign to the container (i.e.
<code>docker run -name &lt;key&gt; ...</code>). Values are either
a string&mdash;in which case they are assumed to refer to an image&mdash;or an
object. A definition of two containers demonstrating
both approaches might look a bit like this:</p>

<pre><code>"containers": {
  "nfprocessor": {
    "image": "makeusabrew/nodeflakes-processor",
    "port" : ["1234:1234"],
    "env"  : ["MY_ENV_VAR=value", "ANOTHER_VAR=foo"],
    "dependencies": [
      "nfconsumer:consumer"
    ],
    "mount": ["/path/to/host-dir:/path/to/container-dir"],
    "mount-from": ["nfconsumer"]
  },
  "nfconsumer": "makeusabrew/nodeflakes-consumer"
}
</code></pre>

<p>Each key in the definition of <code>nfprocessor</code> maps loosely onto
an argument which will be passed to <code>docker run</code>. The currently
supported options are:</p>

<pre class="">port         &rarr; <b>-p</b>
env          &rarr; <b>-e</b>
dependencies &rarr; <b>-link</b>
mount        &rarr; <b>-v</b>
mount-from   &rarr; <b>--volumes-from</b>
privileged   &rarr; <b>-privileged</b>
image        &rarr; used as-is
extra        &rarr; extra runtime arguments, used as-is after the 'image' argument</pre>

<!--<p>It might be simpler to remove this abstraction and just name these keys exactly as per the arguments passed to docker run, but you&rsquo;d end up with some pretty ugly looking definitions full of single letter keys. Nevertheless, this <em>may</em> change.</p>-->

<h3>
<a name="format-clusters" class="anchor"><span class="octicon octicon-link"></span></a>clusters</h3>

<ul class="requirements">
  <li>required: <b>yes</b></li>
</ul>

<p>Clusters define sets of related containers which&mdash;presumably&mdash;combine
in some useful way (e.g. a master &amp; slave database, a couple of web servers
and a load balancer). This is where it all happens!

<p>Each key is an arbitrary name to refer to the cluster by when using the
cluster related commands. Values are usually
just arrays of names found in the <code>containers</code> object. These
definitions are simple as most of the configuration has already been done
elsewhere:</p>

<pre><code>"clusters": {
  "main": ["nfprocessor", "nfconsumer"]
}
</code></pre>

<p>The order we list our containers as part of each cluster definition
doesn&rsquo;t matter&mdash;decking will resolve the dependencies based on each
container&rsquo;s definition and make sure they start in the correct order.
Similarly, dependencies don&rsquo;t <i>have</i> to be explicitly listed as part
of a cluster; if you want to run containers A and B as a cluster, and B
happens to depend on C, then C will be started too&mdash;even if you aren&rsquo;t
really interested in it when mentally modelling your cluster.</p>

<!--
<p>In this example as we have only defined one cluster we can omit it when
calling any of the cluster related commands &ndash; e.g.
<code>decking start main</code> can be shortened to
<code>decking start</code>. If two or more cluster definitions are present
then a cluster name must always be provided as otherwise decking won&rsquo;t
know which one you&rsquo;re refering to.</p>
-->

<h3>
<a name="format-groups" class="anchor"><span class="octicon octicon-link"></span></a>groups</h3>

<ul class="requirements">
  <li>required: <b>no</b></li>
</ul>

<p>Groups allow clusters of containers to be run with different parameters, usually
to support small configuration variations across different environments (e.g.
build, test, production) without having to define entirely new containers.</p>

<p>Each key is an arbitrary name to associate with each group. Values are
cluster-wide and container-specific overrides:</p>

<pre><code>"groups": {
    "build": {
        "options": {
            "env":   ["NODE_ENV=build"],
            "mount": [".:/path/to/src"]
        },
        "containers": {
            "nfprocessor": {
                "port": ["4321:1234"]
            }
        }
    }

}
</code></pre>

<p>The above would create a new group called <code>build</code>, which when
used would apply the relevant options when creating a cluster of containers.
Per-container overrides can also be set, though these are optional. Opting
into a group simply requires a slightly different cluster definition:</p>

<pre><code>"clusters": {
  "main": ["nfprocessor", "nfconsumer"],
  "dev": {
      "group": "build",
      "containers": ["nfprocessor", "nfconsumer"]
  }
}
</code></pre>

<p>This would let us run two clusters based on the same containers, albeit one very clearly in
&lsquo;build&rsquo; mode. Of course we can&rsquo;t have two containers with different configurations sharing
the same <code>-name</code>, so decking namespaces containers based on the group name. In the above example,
a call to <code>decking create dev</code> would look for containers named <code>nfprocessor.build</code> and
<code>nfconsumer.build</code>. This namespacing is transparent to a user, meaning containers can always
be thought of and referred to (i.e. as dependencies) by their original name.</p>

<p>Note that for now, group-wide options completely overwrite any previous values for matching keys
rather than merge them with existing ones. Likewise, a container-level override overwrites
any previous values (even those set at group level). This will be changed in future such that
options are merged properly in a predictable manner.</p>

<h2>
<a name="commands" class="anchor"><span class="octicon octicon-link"></span></a>Commands</h2>

<p>Every command relates to the orchestration of containers into clusters with one
exception&mdash;build&mdash;which relates to the base images powering each container.</p>

<h3>
<a name="commands-build" class="anchor"><span class="octicon octicon-link"></span></a>build [image] [--no-cache]</h3>

<p>When provided with a valid image name found in the decking definition file, this copies the
referenced Dockerfile to the project root before building it.</p>

<p>When provided with the literal string &lsquo;all&rsquo; this simply iterates through each key
of the images object and builds them in turn.</p>

<p>Use <code>--no-cache</code> to prevent Docker using cached layers during the build.</p>

<h3>
<a name="commands-create" class="anchor"><span class="octicon octicon-link"></span></a>create [cluster]</h3>

<p>Builds containers for a given cluster as well as any implicit or explicit dependencies. Optionally
uses group-level overrides if specified by the cluster definition. This method is safe to run multiple
times; it will only create the containers in the cluster which don&rsquo;t already exist.</p>

<h3>
<a name="commands-start" class="anchor"><span class="octicon octicon-link"></span></a>start [cluster]</h3>

<p>Starts all the containers in a given cluster. Safe to run multiple times; it
will only start containers which aren&rsquo;t already running. Ensures that any
dependencies are always started before their dependent services.</p>

<h3>
<a name="commands-stop" class="anchor"><span class="octicon octicon-link"></span></a>stop [cluster]</h3>

<p>Stops all the containers in a given cluster. Safe to run multiple times; it
will only stop containers which are currently running.</p>

<h3>
<a name="commands-restart" class="anchor"><span class="octicon octicon-link"></span></a>restart [cluster]</h3>

<p>Restarts the containers in a given cluster. As with <code>start</code>,
all dependencies are restarted in the correct order.</p>

<h3>
<a name="commands-status" class="anchor"><span class="octicon octicon-link"></span></a>status [cluster]</h3>

<p>Provides a quick overview of the status of each container in a cluster.
Also displays each container&rsquo;s IP and port mapping information if
it is currently running.</p>

<h3>
<a name="commands-attach" class="anchor"><span class="octicon octicon-link"></span></a>attach [cluster]</h3>

<p>Attaches to the stdout and stderr streams of each container in a cluster.
This is <i>incredibly</i> useful for gaining an insight into the overall
cohesion of a cluster and provides a coordinated output log. Survives
brief outages in container availibility meaning it does not have to be
re run each time a container is restarted.</p>

<h2>
<a name="advanced-usage" class="anchor"><span class="octicon octicon-link"></span></a>Advanced Usage</h2>

<p>While the basic decking configuration is simple yet powerful,
occasionally you may need to use some more advanced configuration techniques:</p>

<h3>
<a name="advanced-dynamic" class="anchor"><span class="octicon octicon-link"></span></a>Dynamic environment variables</h3>

<p>Environment variables are often used for information you
wouldn&rsquo;t want commiting to source control; either because it is
sensitive (e.g. a secret API token) or unpredictable (e.g. something which
varies per host, such as the host&rsquo;s IP address). Decking allows
you to specify a dash value (literally, a <code>-</code>) for
environment variables which it will try to resolve when creating a
container. Let&rsquo;s look at a very simple example first:</p>

<pre><code>"containers": {
  "api_consumer": {
    "image": "makeusabrew/twitter-consumer",
    "env": : ["NODE_ENV=build", "CONSUMER_KEY=-"]
  }
}</code></pre>

<p>When a cluster containing this container is first created, decking will
notice the dash value and check the host machine&rsquo;s
<code>$CONSUMER_KEY</code> environment variable. If that yields an empty value
the user will be prompted for it; the user&rsquo;s input will be masked in
case the data is sensitive. As Docker stores environment variables as
part of a container&rsquo;s configuration, this information will only
be prompted for once, upon container creation. The value stored by the
container is a snapshot; it does not change when the container is stopped
or started.</p>

<h3>
<a name="advanced-multi" class="anchor"><span class="octicon octicon-link"></span></a>Multiple instances of the same container in a cluster</h3>

<p>It is not uncommon to have multiple instances of a service working together
as part of a cluster (e.g. a group of workers which listen out for data before
processing it). Since these cases are effectively just &gt; 1 instance of
the same container, there is no need to provide a separate container definition
for each node. Let&rsquo;s take a look at another example based on our previous
API consumer:</p>

<pre><code>"containers": {
  "api_consumer": {
    "image": "makeusabrew/twitter-consumer",
    "env": : ["NODE_ENV=build", "CONSUMER_KEY=-"]
  },
  "data_processor": {
    "image": "makeusabrew/twitter-processor",
    "dependencies": ["redis"]
  }
}</code></pre>

<p>(We&rsquo;ve snuck in a dependency on a &lsquo;redis&rsquo; container
here since our processors are probably going to pump data into it, but
it&rsquo;s not relevant to the example!)</p>

<p>Let&rsquo;s say in build mode we only want one data processor; we&rsquo;d
just define our cluster definition as usual:</p>

<pre><code>"clusters": {
  "build": ["api_consumer", "data_processor"]
}
</code></pre>

<p>But in production we want more data processors to take full advantage of
our server:</p>

<pre><code>"clusters": {
  "build": ["api_consumer", "data_processor"],
  "prod": ["api_consumer", "data_processor(8)"]
}
</code></pre>

<p>Voila; a call to <code>decking start prod</code> will now spawn eight
instances of our data processor.</p>

<p>Note that multi-node containers will be named accordingly. Our
data processor would simply be called <code>data_processor</code>
whereas our production containers would be named
<code>data_processor.1</code> &hellip; <code>data_processor.8</code>
to avoid clashing with each other.</p>

<p>There is one outstanding issue with multi-node containers; since they
all use the same container definition there is a problem if that definition
specifies something which should vary per container instance. A concrete
example of this would be a web node which binds to a specific port on
the host; docker will error when trying to bind another container to that
port (in this scenario don&rsquo;t bind to a specific host port&mdash;use
a load balancer and links instead!). This will be addressed in a future
release.</p>

<h2>
<a name="faq" class="anchor"><span class="octicon octicon-link"></span></a>Miscellaneous Notes</h2>

<p>Some useful information which doesn't quite fit elsewhere&hellip;</p>

<h3>
<a name="faq-names" class="anchor"><span class="octicon octicon-link"></span></a>Container naming conventions</h3>

<p>In general, containers will be named exactly as per their keys in the
<a href="format-containers">containers</a> object. There are however some exceptions to this rule:</p>

<ol>
  <li>If a cluster specifies a <a href="#format-groups">group</a> override</li>
  <li>If a cluster specifies a <a href="#advanced-multi">multi-instance</a> container</li>
  <li>If a cluster specifies both 1 &amp; 2.</li>
</ol>

<p>A base container named <code>redis</code> would therefore have the following namespacing
should it meet the relevant rules:</p>

<ol>
  <li>redis.[group] (where group = the key name of the group)</li>
  <li>redis.[n] (where n = an index between 1 and the number of desired instances)</li>
  <li>redis.[group].[n]</li>
</ol>

<p>These rules indicate that a cluster name by itself <b>will not</b> namespace a container;
that is, a container named in two clusters will use the same instance. This is because
clusters are not tied one to one with &lsquo;modes&rsquo; (where different
containers would be desirable in different clusters)&mdash;it is quite possible different
clusters may well want to use the same instance of a container. If this isn&rsquo;t what
you want then be sure to opt-in to a group override in each cluster (and see the following
note).</p>

<h3>
<a name="faq-group-optin" class="anchor"><span class="octicon octicon-link"></span></a>Automatic group opt-in</h3>

<p>Since the majority of use-cases (thus far) usually associate a cluster with a different
environment decking will automatically opt-in to a group with the same name as
a given cluster if it exists. For example, a cluster named <code>dev</code> will
look for a group named <code>dev</code> and use its overrides&mdash;<b>and</b>
namespacing&mdash;if it exists. This eliminates needless configuration like this:</p>

<pre><code>"clusters": {
  "test": {
      "group": "test",
      "containers": ["nfprocessor", "nfconsumer"]
  },
  "dev": {
      "group": "dev",
      "containers": ["nfprocessor", "nfconsumer"]
  }
}</code></pre>

<p>Which, assuming groups named <code>dev</code> and <code>test</code> exist, can
simply be written as:</p>

<pre><code>"clusters": {
  "test": ["nfprocessor", "nfconsumer"],
  "dev": ["nfprocessor", "nfconsumer"]
}</code></pre>

<p>Thus if you find your clusters accidentally opting in to group overrides, simply
ensure they have different names.</p>

        </section>

        <aside id="sidebar">

          <p class="repo-owner"><a href="https://github.com/makeusabrew/decking">decking</a> is maintained by <a href="https://github.com/makeusabrew">makeusabrew</a>.</p>

          <ul>
            <li><a href=#installation>Installation</a></li>
            <li><a href=#about>Why decking?</a></li>
            <li><a href=#format>The decking.json format</a>
              <ul class="nested">
                <li><a href="#format-images">images</a></li>
                <li><a href="#format-containers">containers</a></li>
                <li><a href="#format-clusters">clusters</a></li>
                <li><a href="#format-groups">groups</a></li>
              </ul>
            </li>
            <li><a href=#commands>Commands</a>
              <ul class="nested">
                <li><a href="#commands-build">build</a></li>
                <li><a href="#commands-create">create</a></li>
                <li><a href="#commands-start">start</a></li>
                <li><a href="#commands-stop">stop</a></li>
                <li><a href="#commands-restart">restart</a></li>
                <li><a href="#commands-attach">attach</a></li>
              </ul>
            </li>
            <li><a href=#advanced-usage>Advanced usage</a>
              <ul class="nested">
                <li><a href="#advanced-dynamic">Dynamic env vars</a></li>
                <li><a href="#advanced-multi">Multi-node containers</a></li>
              </ul>
            </li>
            <li><a href=#faq>Notes</a></li>
          </ul>

          <a href="https://npmjs.org/package/decking" class="button">
            <small>Download via npm</small>
            v0.3.0
          </a>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-20517424-10");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
